<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hill Prairie Research - Driftless Region</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/leaflet.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            text-align: center;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }

        .header h1 {
            color: #2c5530;
            margin-bottom: 10px;
            font-size: 2.2em;
        }

        .header p {
            color: #5a6b5d;
            max-width: 800px;
            margin: 0 auto;
            line-height: 1.6;
        }

        .container {
            display: flex;
            height: calc(100vh - 120px);
            background: white;
        }

        .sidebar {
            width: 350px;
            background: rgba(255, 255, 255, 0.98);
            padding: 20px;
            overflow-y: auto;
            box-shadow: 2px 0 10px rgba(0,0,0,0.1);
        }

        .map-container {
            flex: 1;
            position: relative;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        .control-group {
            margin-bottom: 25px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 4px solid #28a745;
        }

        .control-group h3 {
            color: #2c5530;
            margin-bottom: 15px;
            font-size: 1.1em;
        }

        .layer-control {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            padding: 8px;
            background: white;
            border-radius: 5px;
            transition: all 0.3s ease;
        }

        .layer-control:hover {
            background: #e9ecef;
            transform: translateX(5px);
        }

        .layer-control input {
            margin-right: 10px;
        }

        .layer-control label {
            flex: 1;
            cursor: pointer;
            font-weight: 500;
        }

        .legend {
            background: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-top: 15px;
        }

        .legend h4 {
            color: #2c5530;
            margin-bottom: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            margin-right: 10px;
            border: 1px solid #ddd;
        }

        .stats-panel {
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .stat-value {
            font-weight: bold;
            font-size: 1.1em;
        }

        .enhanced-popup {
            font-family: 'Segoe UI', sans-serif;
            max-width: 380px;
        }

        .species-header h3 {
            color: #2c5530;
            margin-bottom: 5px;
            border-bottom: 2px solid #28a745;
            padding-bottom: 5px;
            font-size: 1.1em;
        }

        .scientific-name {
            color: #666;
            font-size: 0.95em;
            margin-bottom: 3px;
            font-style: italic;
        }

        .taxonomic-rank {
            color: #888;
            font-size: 0.8em;
            text-transform: capitalize;
            margin-bottom: 10px;
        }

        .image-gallery {
            margin: 10px 0;
            text-align: center;
            max-height: 90px;
            overflow-x: auto;
            white-space: nowrap;
        }

        .obs-image {
            display: inline-block;
            transition: transform 0.2s;
        }

        .obs-image:hover {
            transform: scale(1.1);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .no-image {
            text-align: center;
            color: #999;
            font-style: italic;
            margin: 10px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 4px;
        }

        .observation-details {
            margin: 12px 0;
        }

        .observation-description {
            background: #f8f9fa;
            padding: 8px;
            border-radius: 4px;
            margin: 10px 0;
            font-size: 0.9em;
            line-height: 1.4;
        }

        .popup-links {
            margin: 12px 0;
        }

        .popup-links a {
            display: inline-block;
            margin-right: 10px;
            margin-bottom: 5px;
            color: #74ac00;
            text-decoration: none;
            font-size: 0.9em;
            font-weight: 500;
        }

        .popup-links a:hover {
            text-decoration: underline;
        }

        .data-source {
            font-size: 0.8em;
            color: #666;
            text-align: center;
            margin-top: 12px;
            padding-top: 8px;
            border-top: 1px solid #eee;
        }

        .quality-research {
            color: #28a745;
        }

        .quality-needs_id {
            color: #ffc107;
        }

        .quality-casual {
            color: #6c757d;
        }

        .enhanced-inat-popup .leaflet-popup-content {
            margin: 8px 12px;
        }

        .connectivity-high { background-color: #28a745; }
        .connectivity-medium { background-color: #ffc107; }
        .connectivity-low { background-color: #dc3545; }
        
        .habitat-excellent { background-color: #155724; }
        .habitat-good { background-color: #28a745; }
        .habitat-fair { background-color: #856404; }
        .habitat-poor { background-color: #721c24; }

        .loading-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255,255,255,0.95);
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            z-index: 1000;
            text-align: center;
        }

        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #28a745;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            border: 1px solid #f5c6cb;
        }

        .success-message {
            background: #d4edda;
            color: #155724;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            border: 1px solid #c3e6cb;
        }

        .data-toggle {
            background: #e3f2fd;
            border-left-color: #2196f3;
        }

        .imagery-toggle {
            background: #fff3e0;
            border-left-color: #ff9800;
        }

        .elevation-toggle {
            background: #fce4ec;
            border-left-color: #e91e63;
        }

        .training-marker { background-color: #28a745; }
        .validation-marker { background-color: #9c27b0; }
        .example-marker { background-color: #ff9800; }

        select {
            width: 100%;
            padding: 8px;
            margin: 5px 0 10px 0;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 0.9em;
        }

        select:focus {
            border-color: #28a745;
            outline: none;
        }

        .api-status {
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            font-size: 0.9em;
            display: flex;
            align-items: center;
        }

        .api-status.loading {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
        }

        .api-status.success {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }

        .api-status.error {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }

        .status-icon {
            margin-right: 8px;
            font-size: 1.1em;
        }

        .refresh-button {
            background: #28a745;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            margin-top: 10px;
            transition: background-color 0.3s;
        }

        .refresh-button:hover {
            background: #218838;
        }

        .refresh-button:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }

        .filter-info {
            background: #e7f3ff;
            padding: 10px;
            border-radius: 5px;
            font-size: 0.85em;
            color: #0366d6;
            margin-top: 10px;
        }

        .under-development-banner {
            display: flex;
            align-items: center;
            padding: 15px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 8px;
            border: 2px dashed #6c757d;
            margin: 10px 0;
        }

        .banner-icon {
            font-size: 2em;
            margin-right: 15px;
            opacity: 0.7;
        }

        .banner-content {
            flex: 1;
        }

        .banner-content strong {
            display: block;
            color: #495057;
            font-size: 1.1em;
            margin-bottom: 4px;
        }

        .banner-content p {
            margin: 0;
            color: #6c757d;
            font-size: 0.9em;
            font-style: italic;
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                height: 350px;
            }
            
            .map-container {
                height: calc(100vh - 470px);
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Hill Prairie Research - Driftless Region</h1>
        <p>Interactive visualization of remnant hill prairie connectivity, species distributions, and conservation priorities in the Driftless Region. Local iNaturalist data from prairie remnant buffer zones integrated with research datasets.</p>
    </div>

    <div class="container">
        <div class="sidebar">
            <div class="control-group data-toggle">
                <h3>Data Sources</h3>
                <div class="layer-control">
                    <input type="checkbox" id="show-example" checked>
                    <label for="show-example">Example/Demo Sites</label>
                </div>
                <div class="layer-control">
                    <input type="checkbox" id="show-training">
                    <label for="show-training">ML Training Sites</label>
                </div>
                <div class="layer-control">
                    <input type="checkbox" id="show-validation">
                    <label for="show-validation">ML Validation Sites</label>
                </div>
                <div class="layer-control">
                    <input type="checkbox" id="show-inaturalist" checked>
                    <label for="show-inaturalist">iNaturalist Data</label>
                </div>

                <div id="inaturalist-status" class="api-status loading">
                    <span class="status-icon">🔄</span>
                    <span>Loading iNaturalist observations from local data...</span>
                </div>
                
                <button id="refresh-inaturalist" class="refresh-button" disabled>
                    Refresh Filters
                </button>
                
                <div class="filter-info">
                    <strong>Data Source:</strong> Pre-downloaded iNaturalist observations<br>
                    <strong>Area:</strong> Remnant prairie sites + buffer zones<br>
                    <strong>File:</strong> data/iNat.geojson<br>
                    <strong>Active Filter:</strong> Minimum observations per species
                </div>
            </div>

            <div class="control-group imagery-toggle">
                <h3>Wisconsin DNR Imagery</h3>
                <div class="under-development-banner">
                    <div class="banner-icon">🚧</div>
                    <div class="banner-content">
                        <strong>Under Development</strong>
                        <p>Historical imagery layers coming soon</p>
                    </div>
                </div>
            </div>

            <div class="control-group elevation-toggle">
                <h3>Wisconsin DNR Elevation</h3>
                <div class="under-development-banner">
                    <div class="banner-icon">🗻</div>
                    <div class="banner-content">
                        <strong>Under Development</strong>
                        <p>LiDAR and terrain analysis layers coming soon</p>
                    </div>
                </div>
            </div>

            <div class="control-group">
                <h3>Map Layers</h3>
                <div class="layer-control">
                    <input type="checkbox" id="prairies" checked>
                    <label for="prairies">Hill Prairie Remnants</label>
                </div>
                <div class="layer-control">
                    <input type="checkbox" id="connectivity">
                    <label for="connectivity">Connectivity Corridors</label>
                </div>
                <div class="layer-control">
                    <input type="checkbox" id="species">
                    <label for="species">Species Observations</label>
                </div>
                <div class="layer-control">
                    <input type="checkbox" id="habitat">
                    <label for="habitat">Habitat Suitability</label>
                </div>
                <div class="layer-control">
                    <input type="checkbox" id="priority">
                    <label for="priority">Conservation Priority</label>
                </div>
            </div>

            <div class="control-group">
                <h3>Data Filters</h3>
                <label>Connectivity Score:</label>
                <input type="range" id="connectivity-filter" min="0" max="100" value="0" style="width: 100%; margin: 10px 0;">
                <div style="display: flex; justify-content: space-between; font-size: 0.9em; color: #666;">
                    <span>Low</span><span>High</span>
                </div>
                
                <label style="margin-top: 15px; display: block;">Species Richness:</label>
                <input type="range" id="species-filter" min="0" max="50" value="0" style="width: 100%; margin: 10px 0;">
                <div style="display: flex; justify-content: space-between; font-size: 0.9em; color: #666;">
                    <span>0</span><span>50+</span>
                </div>

                <label style="margin-top: 15px; display: block;">Min observations per species:</label>
                <input type="range" id="min-obs-filter" min="1" max="20" value="2" style="width: 100%; margin: 10px 0;">
                <div style="display: flex; justify-content: space-between; font-size: 0.9em; color: #666;">
                    <span>1</span><span>20+</span>
                </div>
            </div>

            <div class="legend">
                <h4>Data Sources</h4>
                <div class="legend-item">
                    <div class="legend-color example-marker"></div>
                    <span>Example/Demo Sites</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color training-marker"></div>
                    <span>ML Training Data</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color validation-marker"></div>
                    <span>ML Validation Data</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #74ac00;"></div>
                    <span>iNaturalist Observations</span>
                </div>
                
                <h4 style="margin-top: 15px;">Prairie Quality</h4>
                <div class="legend-item">
                    <div class="legend-color habitat-excellent"></div>
                    <span>Excellent (>80%)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color habitat-good"></div>
                    <span>Good (60-80%)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color habitat-fair"></div>
                    <span>Fair (40-60%)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color habitat-poor"></div>
                    <span>Poor (<40%)</span>
                </div>

                <h4 style="margin-top: 15px;">Observation Frequency</h4>
                <div class="legend-item">
                    <div style="width: 12px; height: 12px; background: #74ac00; border-radius: 50%; margin-right: 13px; border: 1px solid #4a6b00;"></div>
                    <span>1-5 observations</span>
                </div>
                <div class="legend-item">
                    <div style="width: 16px; height: 16px; background: #74ac00; border-radius: 50%; margin-right: 11px; border: 1px solid #4a6b00;"></div>
                    <span>6-15 observations</span>
                </div>
                <div class="legend-item">
                    <div style="width: 20px; height: 20px; background: #74ac00; border-radius: 50%; margin-right: 9px; border: 1px solid #4a6b00;"></div>
                    <span>16+ observations</span>
                </div>
            </div>

            <div class="stats-panel">
                <h4>Study Area Summary</h4>
                <div class="stat-item">
                    <span>Prairie Remnants:</span>
                    <span class="stat-value" id="stat-prairies">Loading...</span>
                </div>
                <div class="stat-item">
                    <span>Total Area:</span>
                    <span class="stat-value" id="stat-area">Loading...</span>
                </div>
                <div class="stat-item">
                    <span>Species Observed:</span>
                    <span class="stat-value" id="stat-species">Loading...</span>
                </div>
                <div class="stat-item">
                    <span>iNaturalist Records:</span>
                    <span class="stat-value" id="stat-inaturalist">Loading...</span>
                </div>
                <div class="stat-item">
                    <span>Last Updated:</span>
                    <span class="stat-value" id="stat-updated">Never</span>
                </div>
            </div>

            <div class="legend">
                <h4>About Your iNaturalist Data</h4>
                <p style="margin-bottom: 10px; font-size: 0.9em; line-height: 1.4;">
                    Displaying pre-downloaded iNaturalist observations from within and around your identified prairie remnants. This targeted dataset provides comprehensive species documentation specific to your study areas without API limitations.
                </p>
                <p style="font-size: 0.8em; color: #666; margin-bottom: 15px;">
                    Data includes observations from research-grade citizen science contributions focused on prairie ecosystems in the Driftless Region. Also includes training areas from the
                    <a href="https://www.inaturalist.org/projects/driftless-remnant-hill-prairies" target="_blank" 
                       style="color: #74ac00; text-decoration: none; font-weight: bold;">
                       Driftless Remnant Hill Prairies
                    </a> project.
                </p>
            </div>

            <div id="error-container"></div>
        </div>

        <div class="map-container">
            <div id="loading" class="loading-indicator" style="display: none;">
                <div class="loading-spinner"></div>
                <h4>Loading prairie data...</h4>
                <p>Fetching training features, validation data, and iNaturalist observations...</p>
            </div>
            <div id="map"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/leaflet.min.js"></script>
    <script>
        // Initialize map centered on Driftless Region
        const map = L.map('map').setView([43.25, -90.8], 10);

        // Add base layers
        const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors'
        });

        const satellite = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            attribution: '© Esri'
        });

        const topo = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}', {
            attribution: '© Esri'
        });

        // Base layer control
        const baseLayers = {
            "OpenStreetMap": osm,
            "Satellite": satellite,
            "Topographic": topo
        };

        osm.addTo(map);
        L.control.layers(baseLayers).addTo(map);

        // Data storage
        let prairieData = [];
        let allFeatures = [];
        let iNaturalistData = [];
        let originalINaturalistData = [];

        // Layer groups
        const prairieLayer = L.layerGroup();
        const connectivityLayer = L.layerGroup();
        const speciesLayer = L.layerGroup();
        const habitatLayer = L.layerGroup();
        const priorityLayer = L.layerGroup();

        // Example prairie sites data
        const exampleData = [
            {
                name: "Kickapoo Valley Reserve",
                lat: 43.45, lng: -90.65,
                area: 185, connectivity: 87, species: 42, quality: 95,
                description: "Large, high-quality remnant with excellent connectivity to surrounding habitats.",
                dataset: "example"
            },
            {
                name: "Governor Dodge State Park",
                lat: 43.21, lng: -90.11,
                area: 73, connectivity: 72, species: 38, quality: 88,
                description: "Well-preserved hill prairie with moderate connectivity corridor potential.",
                dataset: "example"
            },
            {
                name: "Wyalusing State Park",
                lat: 43.15, lng: -91.10,
                area: 94, connectivity: 91, species: 45, quality: 92,
                description: "Mississippi River bluff prairie with high species diversity and connectivity.",
                dataset: "example"
            },
            {
                name: "Blue Mounds State Park",
                lat: 43.04, lng: -89.85,
                area: 67, connectivity: 83, species: 41, quality: 86,
                description: "High-elevation prairie remnant with excellent native plant diversity.",
                dataset: "example"
            }
        ];

        // Example connectivity corridors
        const exampleCorridors = [
            {
                name: "Kickapoo-Coon Creek Corridor",
                coordinates: [[43.45, -90.65], [43.42, -90.70], [43.39, -90.75]],
                quality: "high"
            },
            {
                name: "Mississippi River Bluff Corridor", 
                coordinates: [[43.15, -91.10], [43.12, -91.05], [43.10, -91.00]],
                quality: "high"
            }
        ];

        // Status management
        function updateDataStatus(status, message) {
            const statusEl = document.getElementById('inaturalist-status');
            const refreshBtn = document.getElementById('refresh-inaturalist');
            
            statusEl.className = `api-status ${status}`;
            
            const icons = {
                loading: '🔄',
                success: '✅',
                error: '❌'
            };
            
            statusEl.innerHTML = `<span class="status-icon">${icons[status]}</span><span>${message}</span>`;
            
            refreshBtn.disabled = status === 'loading';
        }

        // Error handling
        function showError(message) {
            const errorContainer = document.getElementById('error-container');
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-message';
            errorDiv.innerHTML = `<strong>Data Loading Issue:</strong> ${message}`;
            errorContainer.appendChild(errorDiv);
            
            setTimeout(() => {
                if (errorDiv.parentNode) errorDiv.remove();
            }, 10000);
        }

        function showSuccess(message) {
            const errorContainer = document.getElementById('error-container');
            const successDiv = document.createElement('div');
            successDiv.className = 'success-message';
            successDiv.innerHTML = `<strong>Success:</strong> ${message}`;
            errorContainer.appendChild(successDiv);
            
            setTimeout(() => {
                if (successDiv.parentNode) successDiv.remove();
            }, 5000);
        }

        // Loading indicator
        function showLoading(show) {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
        }

        // Color functions
        function getQualityColor(quality) {
            return quality > 80 ? '#155724' :
                   quality > 60 ? '#28a745' :
                   quality > 40 ? '#856404' : '#721c24';
        }

        function getDatasetColor(dataset) {
            switch(dataset) {
                case 'training': return '#28a745';
                case 'validation': return '#9c27b0';
                case 'example': return '#ff9800';
                default: return '#6c757d';
            }
        }

        function getObservationRadius(count) {
            return count <= 5 ? 6 : count <= 15 ? 8 : 10;
        }

        // Load iNaturalist GeoJSON data
        async function loadINaturalistData() {
            updateDataStatus('loading', 'Loading iNaturalist observations...');
            showLoading(true);
            
            try {
                console.log('Attempting to load: data/iNat.geojson');
                const response = await fetch('data/iNat.geojson');
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                console.log('iNaturalist GeoJSON loaded:', data);

                if (!data.features || !Array.isArray(data.features)) {
                    throw new Error('Invalid GeoJSON format - no features array found');
                }

                // Process the iNaturalist observations
                const speciesMap = new Map();

                data.features.forEach((feature, index) => {
                    try {
                        const props = feature.properties;
                        const geometry = feature.geometry;
                        
                        if (!geometry || geometry.type !== 'Point') {
                            console.warn(`Feature ${index} has invalid geometry`);
                            return;
                        }

                        const [lng, lat] = geometry.coordinates;
                        
                        if (!lat || !lng || isNaN(lat) || isNaN(lng)) {
                            console.warn(`Feature ${index} has invalid coordinates`);
                            return;
                        }

                        // Extract species information with enhanced property mapping based on your data structure
                        const speciesInfo = {
                            id: props.id || props.ID || props.observation_id || index,
                            taxon_id: props['Taxon_Id'] || props.taxon_id || props.species_id,
                            name: props['Name'] || props.common_name || props.species_name || 'Unknown Species',
                            scientific: props['Taxon_name'] || props.scientific_name || props.taxon_name || 'Unknown',
                            rank: props['Rank'] || props.rank || '',
                            lat: lat,
                            lng: lng,
                            quality_grade: props['Quality'] || props.quality_grade || props.grade || 'unknown',
                            observed_on: props['Date'] || props.observed_on || props.observation_date || props.date,
                            observer_login: props['Observator_login'] || props.observer_login || props.user_login,
                            observer_name: props['Observator_name'] || props.observer_name || props.user_name,
                            description: props['Description'] || props.description || '',
                            geoprivacy: props['Geoprivacy'] || props.geoprivacy || '',
                            precision: props['Precision'] || props.precision || '',
                            uri: props['Observation_url'] || props.uri || props.url || `https://www.inaturalist.org/observations/${props.id || ''}`,
                            taxon_url: props['Taxon_url'] || props.taxon_url || '',
                            // Extract image URLs - handle multiple picture columns
                            images: [
                                props['Picture_1'] || props.picture_1 || props.image_1,
                                props['Picture_2'] || props.picture_2 || props.image_2,
                                props['Picture_3'] || props.picture_3 || props.image_3
                            ].filter(Boolean), // Remove null/undefined values
                            place_name: props.place_guess || props.location || props.place,
                            originalProps: props
                        };

                        // Create a unique key for grouping nearby observations of same species
                        const locationKey = `${speciesInfo.taxon_id}-${lat.toFixed(3)}-${lng.toFixed(3)}`;
                        
                        if (speciesMap.has(locationKey)) {
                            speciesMap.get(locationKey).count++;
                            speciesMap.get(locationKey).observations.push(feature);
                        } else {
                            speciesMap.set(locationKey, {
                                ...speciesInfo,
                                count: 1,
                                observations: [feature]
                            });
                        }
                        
                        // Log first few features for debugging
                        if (index < 3) {
                            console.log(`Sample iNaturalist feature ${index}:`, {
                                name: speciesInfo.name,
                                scientific: speciesInfo.scientific,
                                coords: [lat, lng],
                                properties: Object.keys(props)
                            });
                        }
                        
                    } catch (featureError) {
                        console.warn(`Error processing feature ${index}:`, featureError);
                    }
                });

                // Convert to array and store both original and filtered data
                originalINaturalistData = Array.from(speciesMap.values());
                iNaturalistData = [...originalINaturalistData];
                
                const message = `Loaded ${iNaturalistData.length} unique species locations from ${data.features.length} observations`;
                updateDataStatus('success', message);
                showSuccess(message);
                
                // Update last updated time
                document.getElementById('stat-updated').textContent = new Date().toLocaleTimeString();
                
                return iNaturalistData;

            } catch (error) {
                console.error('Error loading iNaturalist GeoJSON:', error);
                const errorMsg = `Failed to load iNat.geojson: ${error.message}`;
                updateDataStatus('error', errorMsg);
                showError(errorMsg);
                return [];
            } finally {
                showLoading(false);
            }
        }

        // Load GeoJSON data (training/validation datasets)
        async function loadGeoJSONData() {
            showLoading(true);
            let loadedDatasets = [];
            
            try {
                // Define all possible data files to check
                const dataFiles = [
                    { file: 'data/training_features.geojson', type: 'training', label: 'Training Features' },
                    { file: 'data/validation_features.geojson', type: 'validation', label: 'Validation Features' },
                    { file: 'data/connectivity_results.geojson', type: 'connectivity', label: 'Connectivity Data' }
                ];

                // Try to load each data file
                for (const dataFile of dataFiles) {
                    try {
                        console.log(`Attempting to load: ${dataFile.file}`);
                        const response = await fetch(dataFile.file);
                        
                        if (response.ok) {
                            const data = await response.json();
                            console.log(`✅ Successfully loaded ${dataFile.label}: ${data.features.length} features`);
                            loadedDatasets.push(dataFile.type);
                            
                            // Process features based on type
                            if (dataFile.type === 'training' || dataFile.type === 'validation') {
                                processLocationFeatures(data, dataFile.type);
                            } else if (dataFile.type === 'connectivity') {
                                processConnectivityFeatures(data);
                            }
                        } else {
                            console.warn(`❌ Failed to load ${dataFile.label}: HTTP ${response.status}`);
                            showError(`${dataFile.label} file returned HTTP ${response.status}. Check file path and server configuration.`);
                        }
                    } catch (fetchError) {
                        console.warn(`❌ Error loading ${dataFile.label}:`, fetchError.message);
                        showError(`Cannot access ${dataFile.label}. Check if file exists in /data folder.`);
                    }
                }

                // Always add example data for demonstration
                prairieData.push(...exampleData);
                console.log(`📊 Total prairie sites loaded: ${prairieData.length}`);

                // Update UI based on what was loaded
                updateDataSourceControls(loadedDatasets);
                
            } catch (error) {
                console.error('❌ Critical error loading GeoJSON data:', error);
                showError('Critical error loading research data files. Using example data only.');
                prairieData = [...exampleData];
            }
            
            showLoading(false);
        }

        // Process location features (training/validation sites)
        function processLocationFeatures(data, datasetType) {
            data.features.forEach((feature, index) => {
                const props = feature.properties;
                
                // Get coordinates - handle different geometry types
                let lat, lng;
                let geometryForDisplay = feature.geometry;
                let isPolygon = false;
                
                try {
                    if (feature.geometry.type === 'Point') {
                        lng = feature.geometry.coordinates[0];
                        lat = feature.geometry.coordinates[1];
                    } else if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {
                        isPolygon = true;
                        // Calculate centroid for polygons
                        const coords = feature.geometry.type === 'Polygon' ? 
                            feature.geometry.coordinates[0] : 
                            feature.geometry.coordinates[0][0];
                        lng = coords.reduce((sum, coord) => sum + coord[0], 0) / coords.length;
                        lat = coords.reduce((sum, coord) => sum + coord[1], 0) / coords.length;
                    } else {
                        console.warn(`Unsupported geometry type: ${feature.geometry.type}`);
                        return;
                    }

                    // Validate coordinates are in expected range (Driftless region)
                    if (lat < 42 || lat > 45 || lng < -93 || lng > -88) {
                        console.warn(`Coordinates outside expected range: ${lat}, ${lng}`);
                    }
                } catch (coordError) {
                    console.error(`Error extracting coordinates for feature ${index}:`, coordError);
                    return;
                }
                
                // Map properties with comprehensive fallbacks
                const siteData = {
                    name: props.site_name || props.name || props.Site_Name || props.location || `${datasetType.charAt(0).toUpperCase() + datasetType.slice(1)} Site ${index + 1}`,
                    lat: lat,
                    lng: lng,
                    area: parseFloat(props.area_ha || props.area || props.Area_ha || props.AREA || 0),
                    connectivity: parseFloat(props.connectivity_score || props.connectivity || props.Connectivity || Math.random() * 100),
                    species: parseInt(props.species_count || props.richness || props.species_richness || props.Species_Count || Math.floor(Math.random() * 50)),
                    quality: parseFloat(props.habitat_quality || props.quality || props.Quality || props.habitat_score || Math.random() * 100),
                    description: props.description || props.Description || props.notes || `${datasetType.charAt(0).toUpperCase() + datasetType.slice(1)} dataset location for ML model`,
                    dataset: datasetType,
                    feature_id: props.id || props.ID || props.FID || index,
                    geometry: geometryForDisplay,
                    isPolygon: isPolygon,
                    originalProps: props
                };
                
                // Log first few features for debugging
                if (index < 3) {
                    console.log(`Sample ${datasetType} feature:`, {
                        name: siteData.name,
                        coords: [lat, lng],
                        area: siteData.area,
                        isPolygon: isPolygon,
                        originalProps: Object.keys(props)
                    });
                }
                
                prairieData.push(siteData);
                allFeatures.push({...feature, displayData: siteData});
            });
        }

        // Process connectivity features (lines/corridors)
        function processConnectivityFeatures(data) {
            console.log(`Processing ${data.features.length} connectivity features`);
            data.features.forEach((feature, index) => {
                if (feature.geometry.type === 'LineString' || feature.geometry.type === 'MultiLineString') {
                    console.log(`Connectivity feature ${index}:`, feature.properties);
                }
            });
        }

        // Update data source controls based on what was successfully loaded
        function updateDataSourceControls(loadedDatasets) {
            const controls = {
                'show-training': loadedDatasets.includes('training'),
                'show-validation': loadedDatasets.includes('validation')
            };

            Object.entries(controls).forEach(([controlId, hasData]) => {
                const control = document.getElementById(controlId);
                const label = control.nextElementSibling;
                
                if (hasData) {
                    control.disabled = false;
                    label.style.opacity = '1';
                    label.title = 'Data loaded successfully';
                } else {
                    control.disabled = true;
                    control.checked = false;
                    label.style.opacity = '0.5';
                    label.title = 'Data file not found or failed to load';
                }
            });
        }

        // Refresh/filter iNaturalist data based on current settings
        function refreshINaturalistData() {
            if (originalINaturalistData.length === 0) {
                showError('No iNaturalist data loaded. Check that data/iNat.geojson exists.');
                return;
            }

            const minObs = document.getElementById('min-obs-filter').value;
            iNaturalistData = originalINaturalistData.filter(species => species.count >= minObs);
            
            console.log(`Filtered to ${iNaturalistData.length} species with at least ${minObs} observations`);
            
            if (document.getElementById('species').checked) {
                updateSpeciesDisplay();
            }
            
            updateStats();
            showSuccess(`Filtered to ${iNaturalistData.length} species meeting criteria`);
        }

        // Update display functions
        function updatePrairieDisplay() {
            const connectivityMin = document.getElementById('connectivity-filter').value;
            const speciesMin = document.getElementById('species-filter').value;
            const showTraining = document.getElementById('show-training').checked;
            const showValidation = document.getElementById('show-validation').checked;
            const showExample = document.getElementById('show-example').checked;
            
            prairieLayer.clearLayers();
            
            prairieData.forEach(prairie => {
                // Filter by dataset type
                if ((prairie.dataset === 'training' && !showTraining) ||
                    (prairie.dataset === 'validation' && !showValidation) ||
                    (prairie.dataset === 'example' && !showExample)) {
                    return;
                }
                
                // Filter by metrics
                if (prairie.connectivity >= connectivityMin && prairie.species >= speciesMin) {
                    let marker;
                    
                    if (prairie.isPolygon && prairie.geometry) {
                        // Render as polygon for training/validation features
                        const coords = prairie.geometry.type === 'Polygon' ? 
                            prairie.geometry.coordinates[0].map(coord => [coord[1], coord[0]]) :
                            prairie.geometry.coordinates[0][0].map(coord => [coord[1], coord[0]]);
                            
                        marker = L.polygon(coords, {
                            color: prairie.dataset === 'example' ? '#2c5530' : 
                                   prairie.dataset === 'training' ? '#1e5928' : '#4a148c',
                            weight: 2,
                            opacity: 0.8,
                            fillColor: prairie.dataset === 'example' ? getQualityColor(prairie.quality) : getDatasetColor(prairie.dataset),
                            fillOpacity: 0.6
                        });
                    } else {
                        // Render as circle marker for point features or fallback
                        marker = L.circleMarker([prairie.lat, prairie.lng], {
                            radius: Math.sqrt(prairie.area) / 2 + 5,
                            fillColor: prairie.dataset === 'example' ? getQualityColor(prairie.quality) : getDatasetColor(prairie.dataset),
                            color: prairie.dataset === 'example' ? '#2c5530' : 
                                   prairie.dataset === 'training' ? '#1e5928' : '#4a148c',
                            weight: 2,
                            opacity: 1,
                            fillOpacity: 0.8
                        });
                    }

                    const popupContent = `
                        <div class="popup-content">
                            <h3>${prairie.name}</h3>
                            <div class="popup-metric">
                                <span>Dataset:</span>
                                <strong>${prairie.dataset.charAt(0).toUpperCase() + prairie.dataset.slice(1)}</strong>
                            </div>
                            <div class="popup-metric">
                                <span>Geometry:</span>
                                <strong>${prairie.isPolygon ? 'Polygon' : 'Point'}</strong>
                            </div>
                            <div class="popup-metric">
                                <span>Area:</span>
                                <strong>${typeof prairie.area === 'number' ? prairie.area.toFixed(1) : prairie.area} hectares</strong>
                            </div>
                            <div class="popup-metric">
                                <span>Connectivity:</span>
                                <strong>${prairie.connectivity.toFixed(1)}%</strong>
                            </div>
                            <div class="popup-metric">
                                <span>Species Count:</span>
                                <strong>${prairie.species}</strong>
                            </div>
                            <div class="popup-metric">
                                <span>Habitat Quality:</span>
                                <strong>${prairie.quality.toFixed(1)}%</strong>
                            </div>
                            <p style="margin-top: 10px; font-style: italic; color: #666;">${prairie.description}</p>
                        </div>
                    `;

                    marker.bindPopup(popupContent);
                    marker.addTo(prairieLayer);
                }
            });
            
            updateStats();
        }

        // Update species observations display
        function updateSpeciesDisplay() {
            const showINaturalist = document.getElementById('show-inaturalist').checked;
            speciesLayer.clearLayers();
            
            if (showINaturalist && iNaturalistData.length > 0) {
                iNaturalistData.forEach(species => {
                    const marker = L.circleMarker([species.lat, species.lng], {
                        radius: getObservationRadius(species.count),
                        fillColor: '#74ac00',
                        color: '#4a6b00',
                        weight: 1,
                        opacity: 1,
                        fillOpacity: 0.8
                    });
                    
                    const popupContent = createEnhancedPopup(species);

                    marker.bindPopup(popupContent, {
                        maxWidth: 400,
                        className: 'enhanced-inat-popup'
                    });
                    marker.addTo(speciesLayer);
                });
                
                console.log(`Displayed ${iNaturalistData.length} species observations`);
            }
        }

        // Update connectivity corridors display
        function updateConnectivityDisplay() {
            connectivityLayer.clearLayers();
            
            exampleCorridors.forEach(corridor => {
                const color = corridor.quality === 'high' ? '#28a745' : 
                             corridor.quality === 'medium' ? '#ffc107' : '#dc3545';
                
                const polyline = L.polyline(corridor.coordinates, {
                    color: color,
                    weight: 4,
                    opacity: 0.8
                });
                
                polyline.bindPopup(`
                    <div class="popup-content">
                        <h3>${corridor.name}</h3>
                        <div class="popup-metric">
                            <span>Quality:</span>
                            <strong>${corridor.quality.charAt(0).toUpperCase() + corridor.quality.slice(1)}</strong>
                        </div>
                    </div>
                `);
                
                polyline.addTo(connectivityLayer);
            });
        }

        // Update habitat suitability display
        function updateHabitatDisplay() {
            habitatLayer.clearLayers();
            
            // Create habitat suitability grid overlay (example)
            const bounds = [[43.0, -91.5], [43.5, -89.5]];
            const imageOverlay = L.imageOverlay('data:image/svg+xml;base64,' + btoa(`
                <svg width="200" height="200" xmlns="http://www.w3.org/2000/svg">
                    <defs>
                        <pattern id="habitat" patternUnits="userSpaceOnUse" width="20" height="20">
                            <rect width="20" height="20" fill="#28a745" opacity="0.3"/>
                            <circle cx="10" cy="10" r="5" fill="#155724" opacity="0.5"/>
                        </pattern>
                    </defs>
                    <rect width="100%" height="100%" fill="url(#habitat)"/>
                </svg>
            `), bounds, {
                opacity: 0.4
            });
            
            imageOverlay.addTo(habitatLayer);
        }

        // Update conservation priority areas
        function updatePriorityDisplay() {
            priorityLayer.clearLayers();
            
            // Example priority polygons
            const priorityAreas = [
                {
                    name: "High Priority Conservation Area",
                    coordinates: [[43.4, -90.7], [43.45, -90.65], [43.42, -90.6], [43.37, -90.65]],
                    priority: "high"
                },
                {
                    name: "Medium Priority Conservation Area", 
                    coordinates: [[43.2, -90.15], [43.25, -90.1], [43.22, -90.05], [43.17, -90.1]],
                    priority: "medium"
                }
            ];
            
            priorityAreas.forEach(area => {
                const color = area.priority === 'high' ? '#dc3545' : 
                             area.priority === 'medium' ? '#ffc107' : '#28a745';
                
                const polygon = L.polygon(area.coordinates, {
                    color: color,
                    weight: 2,
                    opacity: 0.8,
                    fillColor: color,
                    fillOpacity: 0.2
                });
                
                polygon.bindPopup(`
                    <div class="popup-content">
                        <h3>${area.name}</h3>
                        <div class="popup-metric">
                            <span>Priority Level:</span>
                            <strong>${area.priority.charAt(0).toUpperCase() + area.priority.slice(1)}</strong>
                        </div>
                    </div>
                `);
                
                polygon.addTo(priorityLayer);
            });
        }

        // Update statistics panel
        function updateStats() {
            const visiblePrairies = prairieLayer.getLayers().length;
            const totalArea = prairieData.reduce((sum, prairie) => sum + (prairie.area || 0), 0);
            const uniqueSpecies = new Set(iNaturalistData.map(obs => obs.scientific)).size;
            const totalObservations = iNaturalistData.reduce((sum, species) => sum + species.count, 0);
            
            document.getElementById('stat-prairies').textContent = visiblePrairies;
            document.getElementById('stat-area').textContent = totalArea.toFixed(1) + ' ha';
            document.getElementById('stat-species').textContent = uniqueSpecies;
            document.getElementById('stat-inaturalist').textContent = totalObservations;
        }

        // Event listeners for controls
        function setupEventListeners() {
            // Layer toggles
            document.getElementById('prairies').addEventListener('change', function() {
                if (this.checked) {
                    map.addLayer(prairieLayer);
                    updatePrairieDisplay();
                } else {
                    map.removeLayer(prairieLayer);
                }
            });

            document.getElementById('connectivity').addEventListener('change', function() {
                if (this.checked) {
                    map.addLayer(connectivityLayer);
                    updateConnectivityDisplay();
                } else {
                    map.removeLayer(connectivityLayer);
                }
            });

            document.getElementById('species').addEventListener('change', function() {
                if (this.checked) {
                    map.addLayer(speciesLayer);
                    updateSpeciesDisplay();
                } else {
                    map.removeLayer(speciesLayer);
                }
            });

            document.getElementById('habitat').addEventListener('change', function() {
                if (this.checked) {
                    map.addLayer(habitatLayer);
                    updateHabitatDisplay();
                } else {
                    map.removeLayer(habitatLayer);
                }
            });

            document.getElementById('priority').addEventListener('change', function() {
                if (this.checked) {
                    map.addLayer(priorityLayer);
                    updatePriorityDisplay();
                } else {
                    map.removeLayer(priorityLayer);
                }
            });

            // Data source toggles
            ['show-example', 'show-training', 'show-validation', 'show-inaturalist'].forEach(id => {
                document.getElementById(id).addEventListener('change', function() {
                    if (document.getElementById('prairies').checked) {
                        updatePrairieDisplay();
                    }
                    if (document.getElementById('species').checked) {
                        updateSpeciesDisplay();
                    }
                });
            });

            // Filter controls
            document.getElementById('connectivity-filter').addEventListener('input', function() {
                if (document.getElementById('prairies').checked) {
                    updatePrairieDisplay();
                }
            });

            document.getElementById('species-filter').addEventListener('input', function() {
                if (document.getElementById('prairies').checked) {
                    updatePrairieDisplay();
                }
            });

            document.getElementById('min-obs-filter').addEventListener('input', function() {
                refreshINaturalistData();
            });

            // Refresh button
            document.getElementById('refresh-inaturalist').addEventListener('click', function() {
                refreshINaturalistData();
            });
        }

        // Initialize the application
        async function initialize() {
            console.log('Hill Prairie Research Application - Comprehensive Version');
            
            // Set up initial prairie data
            prairieData = [...exampleData];
            
            // Setup event listeners
            setupEventListeners();
            
            // Load research datasets
            await loadGeoJSONData();
            
            // Load iNaturalist data
            await loadINaturalistData();
            
            // Initialize default layers
            map.addLayer(prairieLayer);
            updatePrairieDisplay();
            
            // Add species layer if data was loaded successfully
            if (iNaturalistData.length > 0) {
                map.addLayer(speciesLayer);
                updateSpeciesDisplay();
            }
            
            updateStats();
            console.log('Application initialized successfully');
        }

        // Start the application
        initialize().catch(error => {
            console.error('Failed to initialize application:', error);
            updateDataStatus('error', 'Failed to initialize application. Please refresh the page.');
        });
    </script>
</body>
</html>
